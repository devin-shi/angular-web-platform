/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { map, takeWhile } from 'rxjs/operators';
import { of } from 'rxjs/observable/of';
import { deepCopy } from '@delon/util';
export var /** @type {?} */ FORMATMAPS = {
    'date-time': { widget: 'date' },
    date: { widget: 'date' },
    'full-date': { widget: 'date' },
    time: { widget: 'time' },
    'full-time': { widget: 'time' },
    week: { widget: 'date' },
    month: { widget: 'date' },
    uri: { widget: 'upload' },
    email: { widget: 'autocomplete', type: 'email' },
    '': { widget: 'string' },
};
/**
 * @param {?} o
 * @return {?}
 */
export function isBlank(o) {
    return o == null;
}
/**
 * @param {...?} args
 * @return {?}
 */
export function di() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // tslint:disable-next-line:no-console
    console.warn.apply(console, args);
}
/**
 * 根据 `$ref` 查找 `definitions`
 * @param {?} $ref
 * @param {?=} definitions
 * @return {?}
 */
function findSchemaDefinition($ref, definitions) {
    if (definitions === void 0) { definitions = {}; }
    var /** @type {?} */ match = /^#\/definitions\/(.*)$/.exec($ref);
    if (match && match[1]) {
        // parser JSON Pointer
        var /** @type {?} */ parts = match[1].split('/');
        var /** @type {?} */ current = definitions;
        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
            var part = parts_1[_i];
            part = part.replace(/~1/g, '/').replace(/~0/g, '~');
            if (current.hasOwnProperty(part)) {
                current = current[part];
            }
            else {
                throw new Error("Could not find a definition for " + $ref + ".");
            }
        }
        return current;
    }
    throw new Error("Could not find a definition for " + $ref + ".");
}
/**
 * 取回Schema，并处理 `$ref` 的关系
 * @param {?} schema
 * @param {?=} definitions
 * @return {?}
 */
export function retrieveSchema(schema, definitions) {
    if (definitions === void 0) { definitions = {}; }
    if (schema.hasOwnProperty('$ref')) {
        var /** @type {?} */ $refSchema = findSchemaDefinition(schema.$ref, definitions);
        // remove $ref property
        var $ref = schema.$ref, localSchema = tslib_1.__rest(schema, ["$ref"]);
        return retrieveSchema(tslib_1.__assign({}, $refSchema, localSchema), definitions);
    }
    return schema;
}
/**
 * @param {?} schema
 * @param {?} ui
 * @return {?}
 */
export function resolveIf(schema, ui) {
    if (!(schema.hasOwnProperty('if') && schema.hasOwnProperty('then')))
        return;
    if (!schema.if.properties)
        throw new Error("if: does not contain 'properties'");
    var /** @type {?} */ allKeys = Object.keys(schema.properties), /** @type {?} */
    ifKeys = Object.keys(schema.if.properties);
    detectKey(allKeys, ifKeys);
    detectKey(allKeys, schema.then.required);
    schema.required = schema.required.concat(schema.then.required);
    var /** @type {?} */ hasElse = schema.hasOwnProperty('else');
    if (hasElse) {
        detectKey(allKeys, schema.else.required);
        schema.required = schema.required.concat(schema.else.required);
    }
    var /** @type {?} */ visibleIf = {};
    var /** @type {?} */ visibleElse = {};
    ifKeys.forEach(function (key) {
        var /** @type {?} */ cond = schema.if.properties[key].enum;
        visibleIf[key] = cond;
        if (hasElse)
            visibleElse[key] = function (value) { return !cond.includes(value); };
    });
    schema.then.required.forEach(function (key) { return (ui["$" + key].visibleIf = visibleIf); });
    if (hasElse)
        schema.else.required.forEach(function (key) { return (ui["$" + key].visibleIf = visibleElse); });
    return schema;
}
/**
 * @param {?} keys
 * @param {?} detectKeys
 * @return {?}
 */
function detectKey(keys, detectKeys) {
    detectKeys.forEach(function (key) {
        if (!keys.includes(key)) {
            throw new Error("if: properties does not contain '" + key + "'");
        }
    });
}
/**
 * @param {?} properties
 * @param {?} order
 * @return {?}
 */
export function orderProperties(properties, order) {
    if (!Array.isArray(order))
        return properties;
    var /** @type {?} */ arrayToHash = function (arr) {
        return arr.reduce(function (prev, curr) {
            prev[curr] = true;
            return prev;
        }, {});
    };
    var /** @type {?} */ errorPropList = function (arr) {
        return arr.length > 1
            ? "properties '" + arr.join("', '") + "'"
            : "property '" + arr[0] + "'";
    };
    var /** @type {?} */ propertyHash = arrayToHash(properties);
    var /** @type {?} */ orderHash = arrayToHash(order);
    var /** @type {?} */ extraneous = order.filter(function (prop) { return prop !== '*' && !propertyHash[prop]; });
    if (extraneous.length) {
        throw new Error("ui schema order list contains extraneous " + errorPropList(extraneous));
    }
    var /** @type {?} */ rest = properties.filter(function (prop) { return !orderHash[prop]; });
    var /** @type {?} */ restIndex = order.indexOf('*');
    if (restIndex === -1) {
        if (rest.length) {
            throw new Error("ui schema order list does not contain " + errorPropList(rest));
        }
        return order;
    }
    if (restIndex !== order.lastIndexOf('*')) {
        throw new Error('ui schema order list contains more than one wildcard item');
    }
    var /** @type {?} */ complete = order.slice();
    complete.splice.apply(complete, [restIndex, 1].concat(rest));
    return complete;
}
/**
 * @param {?} uiSchema
 * @return {?}
 */
export function getUiOptions(uiSchema) {
    if (!uiSchema)
        return {};
    return Object.keys(uiSchema)
        .filter(function (key) { return !key.startsWith('$'); })
        .reduce(function (options, key) {
        return tslib_1.__assign({}, options, (_a = {}, _a[key] = uiSchema[key], _a));
        var _a;
    }, /** @type {?} */ ({}));
}
/**
 * @param {?} list
 * @param {?} formData
 * @return {?}
 */
export function getEnum(list, formData) {
    if (isBlank(list) || !Array.isArray(list) || list.length === 0)
        return [];
    if (typeof list[0] !== 'object') {
        list = list.map(function (item) {
            return /** @type {?} */ ({ label: item, value: item });
        });
    }
    if (formData) {
        if (!Array.isArray(formData))
            formData = [formData];
        list.forEach(function (item) {
            if (~formData.indexOf(item.value))
                item.checked = true;
        });
    }
    return list;
}
/**
 * @param {?} list
 * @param {?} formData
 * @return {?}
 */
export function getCopyEnum(list, formData) {
    return getEnum(deepCopy(list || []), formData);
}
/**
 * @param {?} schema
 * @param {?} ui
 * @param {?} formData
 * @param {?=} asyncArgs
 * @return {?}
 */
export function getData(schema, ui, formData, asyncArgs) {
    if (typeof ui.asyncData === 'function') {
        return ui
            .asyncData(asyncArgs)
            .pipe(takeWhile(function () { return ui["__destroy"] !== true; }), map(function (list) { return getEnum(list, formData); }));
    }
    return of(getCopyEnum(schema.enum, formData));
}
//# sourceMappingURL=utils.js.map