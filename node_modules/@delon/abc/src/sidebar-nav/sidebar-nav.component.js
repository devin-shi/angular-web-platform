/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, ElementRef, Renderer2, Inject, HostListener, ChangeDetectionStrategy, ChangeDetectorRef, Input, Output, EventEmitter, } from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';
import { DOCUMENT, LocationStrategy } from '@angular/common';
import { filter } from 'rxjs/operators';
import { MenuService, SettingsService } from '@delon/theme';
var /** @type {?} */ SHOWCLS = 'nav-floating-show';
var /** @type {?} */ FLOATINGCLS = 'nav-floating';
var SidebarNavComponent = /** @class */ (function () {
    function SidebarNavComponent(menuSrv, settings, router, locationStrategy, render, cd, doc, el) {
        this.menuSrv = menuSrv;
        this.settings = settings;
        this.router = router;
        this.locationStrategy = locationStrategy;
        this.render = render;
        this.cd = cd;
        this.doc = doc;
        this.list = [];
        this.autoCloseUnderPad = true;
        this.select = new EventEmitter();
        this.rootEl = /** @type {?} */ (el.nativeElement);
    }
    /**
     * @return {?}
     */
    SidebarNavComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.bodyEl = this.doc.querySelector('body');
        this.menuSrv.openedByUrl(this.router.url);
        this.genFloatingContainer();
        this.change$ = /** @type {?} */ (this.menuSrv.change.subscribe(function (res) {
            _this.list = res;
            _this.cd.detectChanges();
        }));
        this.installUnderPad();
    };
    /**
     * @param {?} e
     * @return {?}
     */
    SidebarNavComponent.prototype.floatingAreaClickHandle = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.stopPropagation();
        e.preventDefault();
        var /** @type {?} */ linkNode = /** @type {?} */ (e.target);
        if (linkNode.nodeName !== 'A') {
            return false;
        }
        var /** @type {?} */ url = linkNode.getAttribute('href');
        if (url && url.startsWith('#')) {
            url = url.slice(1);
        }
        // 如果配置了bashHref 则去掉baseHref
        var /** @type {?} */ baseHerf = this.locationStrategy.getBaseHref();
        if (baseHerf) {
            url = url.slice(baseHerf.length);
        }
        this.router.navigateByUrl(url);
        this.onSelect(this.menuSrv.getPathByUrl(url).pop());
        this.hideAll();
        return false;
    };
    /**
     * @return {?}
     */
    SidebarNavComponent.prototype.clearFloatingContainer = /**
     * @return {?}
     */
    function () {
        if (!this.floatingEl)
            return;
        this.floatingEl.removeEventListener('click', this.floatingAreaClickHandle.bind(this));
        // fix ie: https://github.com/cipchk/delon/issues/52
        if (this.floatingEl.hasOwnProperty('remove')) {
            this.floatingEl.remove();
        }
        else if (this.floatingEl.parentNode) {
            this.floatingEl.parentNode.removeChild(this.floatingEl);
        }
    };
    /**
     * @return {?}
     */
    SidebarNavComponent.prototype.genFloatingContainer = /**
     * @return {?}
     */
    function () {
        this.clearFloatingContainer();
        this.floatingEl = this.render.createElement('div');
        this.floatingEl.classList.add(FLOATINGCLS + '-container');
        this.floatingEl.addEventListener('click', this.floatingAreaClickHandle.bind(this), false);
        this.bodyEl.appendChild(this.floatingEl);
    };
    /**
     * @param {?} linkNode
     * @param {?} item
     * @return {?}
     */
    SidebarNavComponent.prototype.genSubNode = /**
     * @param {?} linkNode
     * @param {?} item
     * @return {?}
     */
    function (linkNode, item) {
        var /** @type {?} */ id = "_sidebar-nav-" + item["__id"];
        var /** @type {?} */ node = /** @type {?} */ (linkNode.nextElementSibling.cloneNode(true));
        node.id = id;
        node.classList.add(FLOATINGCLS);
        node.addEventListener('mouseleave', function () {
            node.classList.remove(SHOWCLS);
        }, false);
        this.floatingEl.appendChild(node);
        return node;
    };
    /**
     * @return {?}
     */
    SidebarNavComponent.prototype.hideAll = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ allNode = this.floatingEl.querySelectorAll('.' + FLOATINGCLS);
        for (var /** @type {?} */ i = 0; i < allNode.length; i++) {
            allNode[i].classList.remove(SHOWCLS);
        }
    };
    /**
     * @param {?} linkNode
     * @param {?} node
     * @return {?}
     */
    SidebarNavComponent.prototype.calPos = /**
     * @param {?} linkNode
     * @param {?} node
     * @return {?}
     */
    function (linkNode, node) {
        var /** @type {?} */ rect = linkNode.getBoundingClientRect();
        // bug: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14721015/
        var /** @type {?} */ scrollTop = Math.max(this.doc.documentElement.scrollTop, this.bodyEl.scrollTop);
        var /** @type {?} */ top = rect.top + scrollTop, /** @type {?} */
        left = rect.right + 5;
        node.style.top = top + "px";
        node.style.left = left + "px";
    };
    /**
     * @param {?} e
     * @param {?} item
     * @return {?}
     */
    SidebarNavComponent.prototype.showSubMenu = /**
     * @param {?} e
     * @param {?} item
     * @return {?}
     */
    function (e, item) {
        if (this.settings.layout.collapsed !== true) {
            return;
        }
        e.preventDefault();
        var /** @type {?} */ linkNode = /** @type {?} */ (e.target);
        this.genFloatingContainer();
        var /** @type {?} */ subNode = this.genSubNode(/** @type {?} */ (linkNode), item);
        this.hideAll();
        subNode.classList.add(SHOWCLS);
        this.calPos(/** @type {?} */ (linkNode), subNode);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    SidebarNavComponent.prototype.onSelect = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.select.emit(item);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    SidebarNavComponent.prototype.toggleOpen = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.menuSrv.visit(function (i, p) {
            if (i !== item)
                i["_open"] = false;
        });
        var /** @type {?} */ pItem = item["__parent"];
        while (pItem) {
            pItem._open = true;
            pItem = pItem.__parent;
        }
        item._open = !item._open;
        this.cd.markForCheck();
    };
    /**
     * @return {?}
     */
    SidebarNavComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        this.hideAll();
    };
    /**
     * @return {?}
     */
    SidebarNavComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.change$.unsubscribe();
        if (this.route$)
            this.route$.unsubscribe();
        this.clearFloatingContainer();
    };
    /**
     * @return {?}
     */
    SidebarNavComponent.prototype.installUnderPad = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.autoCloseUnderPad)
            return;
        this.route$ = /** @type {?} */ (this.router.events
            .pipe(filter(function (e) { return e instanceof NavigationEnd; }))
            .subscribe(function (s) { return _this.underPad(); }));
        this.underPad();
    };
    /**
     * @return {?}
     */
    SidebarNavComponent.prototype.underPad = /**
     * @return {?}
     */
    function () {
        if (window.innerWidth < 992 && !this.settings.layout.collapsed) {
            this.settings.setLayout('collapsed', true);
        }
    };
    SidebarNavComponent.decorators = [
        { type: Component, args: [{
                    selector: 'sidebar-nav',
                    template: "<ul class=\"nav\"> <ng-container *ngFor=\"let group of list\"> <ng-template [ngIf]=\"group._hidden !== true\"> <li class=\"nav-group-title\"> <span>{{ group.text }}</span> </li> <ng-container *ngFor=\"let child1 of group.children\"> <li *ngIf=\"child1._hidden !== true\" [routerLinkActive]=\"['nav-item-selected']\" [class.nav-submenu-open]=\"child1._open\"> <!-- link --> <a *ngIf=\"child1._type === 1\" (click)=\"onSelect(child1)\" [routerLink]=\"child1.link\" [target]=\"child1.target\"> <i *ngIf=\"!settings.layout.collapsed\" class=\"{{ child1.icon }}\"></i> <nz-tooltip *ngIf=\"settings.layout.collapsed\" nzPlacement=\"right\" [nzTitle]=\"child1.text\"> <span nz-tooltip> <i class=\"{{ child1.icon }}\"></i> </span> </nz-tooltip> <span>{{ child1.text }}</span> </a> <!-- external link --> <a *ngIf=\"child1._type === 2\" href=\"{{ child1.externalLink }}\" target=\"{{child1.target}}\"> <i *ngIf=\"!settings.layout.collapsed\" class=\"{{ child1.icon }}\"></i> <nz-tooltip *ngIf=\"settings.layout.collapsed\" nzPlacement=\"right\" [nzTitle]=\"child1.text\"> <span nz-tooltip> <i class=\"{{ child1.icon }}\"></i> </span> </nz-tooltip> <span>{{ child1.text }}</span> </a> <!-- has children link --> <a *ngIf=\"child1._type === 3\" class=\"nav-sub-title\" (click)=\"toggleOpen(child1)\" (mouseenter)=\"showSubMenu($event, child1)\"> <i class=\"{{ child1.icon }}\"></i> <span>{{ child1.text }}</span> </a> <!-- badge --> <div *ngIf=\"child1.badge\" title=\"{{child1.badge}}\" class=\"badge badge-{{child1.badge_status}}\" [class.badge-dot]=\"child1.badge_dot\"> <em>{{child1.badge}}</em> </div> <!-- Level 2 --> <ul *ngIf=\"child1._type === 3\" class=\"nav nav-sub nav-depth{{child1._depth}}\"> <ng-container *ngFor=\"let child2 of child1.children\"> <li *ngIf=\"child2._hidden !== true\" [routerLinkActive]=\"['nav-item-selected']\" [class.nav-submenu-open]=\"child2._open\"> <!-- link --> <a *ngIf=\"child2._type === 1\" (click)=\"onSelect(child2)\" [routerLink]=\"child2.link\" [target]=\"child2.target\">{{ child2.text }}</a> <!-- external link --> <a *ngIf=\"child2._type === 2\" href=\"{{ child2.externalLink }}\" target=\"{{ child2.target }}\">{{ child2.text }}</a> <!-- has children link --> <a *ngIf=\"child2._type === 3\" class=\"nav-sub-title\" (click)=\"toggleOpen(child2)\"> {{ child2.text }} </a> <!-- badge --> <div *ngIf=\"child2.badge\" title=\"{{child2.badge}}\" class=\"badge badge-{{child2.badge_status}}\" [class.badge-dot]=\"child2.badge_dot\"> <em>{{child2.badge}}</em> </div> <!-- Level 3 --> <ul *ngIf=\"child2._type === 3\" class=\"nav nav-sub nav-depth{{child2._depth}}\"> <ng-container *ngFor=\"let child3 of child2.children\"> <li *ngIf=\"child3._hidden !== true\" [routerLinkActive]=\"['nav-item-selected']\" [class.nav-submenu-open]=\"child3._open\"> <!-- link --> <a *ngIf=\"child3._type === 1\" (click)=\"onSelect(child3)\" [routerLink]=\"child3.link\" [target]=\"child3.target\">{{ child3.text }}</a> <!-- external link --> <a *ngIf=\"child3._type === 2\" href=\"{{ child3.externalLink }}\" target=\"{{ child3.target }}\">{{ child3.text }}</a> <!-- badge --> <div *ngIf=\"child3.badge\" title=\"{{child3.badge}}\" class=\"badge badge-{{child3.badge_status}}\" [class.badge-dot]=\"child3.badge_dot\"> <em>{{child3.badge}}</em> </div> </li> </ng-container> </ul> </li> </ng-container> </ul> </li> </ng-container> </ng-template> </ng-container> </ul> ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                },] },
    ];
    // endregion
    /** @nocollapse */
    SidebarNavComponent.ctorParameters = function () { return [
        { type: MenuService, },
        { type: SettingsService, },
        { type: Router, },
        { type: LocationStrategy, },
        { type: Renderer2, },
        { type: ChangeDetectorRef, },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
        { type: ElementRef, },
    ]; };
    SidebarNavComponent.propDecorators = {
        "autoCloseUnderPad": [{ type: Input },],
        "select": [{ type: Output },],
        "onClick": [{ type: HostListener, args: ['document:click', ['$event.target'],] },],
    };
    return SidebarNavComponent;
}());
export { SidebarNavComponent };
function SidebarNavComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    SidebarNavComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    SidebarNavComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    SidebarNavComponent.propDecorators;
    /** @type {?} */
    SidebarNavComponent.prototype.rootEl;
    /**
     * \@inner
     * @type {?}
     */
    SidebarNavComponent.prototype.floatingEl;
    /** @type {?} */
    SidebarNavComponent.prototype.bodyEl;
    /** @type {?} */
    SidebarNavComponent.prototype.list;
    /** @type {?} */
    SidebarNavComponent.prototype.change$;
    /** @type {?} */
    SidebarNavComponent.prototype.autoCloseUnderPad;
    /** @type {?} */
    SidebarNavComponent.prototype.select;
    /** @type {?} */
    SidebarNavComponent.prototype.route$;
    /** @type {?} */
    SidebarNavComponent.prototype.menuSrv;
    /** @type {?} */
    SidebarNavComponent.prototype.settings;
    /** @type {?} */
    SidebarNavComponent.prototype.router;
    /** @type {?} */
    SidebarNavComponent.prototype.locationStrategy;
    /** @type {?} */
    SidebarNavComponent.prototype.render;
    /** @type {?} */
    SidebarNavComponent.prototype.cd;
    /** @type {?} */
    SidebarNavComponent.prototype.doc;
}
//# sourceMappingURL=sidebar-nav.component.js.map